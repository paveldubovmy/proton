# -*- coding: utf-8 -*-
"""Untitled30.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18Gk0ZQOtIrtSd4HXg_oj3ftAjxaPRsew
"""

import numpy as np
from scipy.integrate import solve_bvp, simpson
import matplotlib.pyplot as plt

# ГАРАНТИЯ ВЫВОДА: Если работаешь в терминале без монитора, раскомментируй строку ниже:
# plt.switch_backend('Agg')

# =============================================================================
# 1. КОНСТАНТЫ (NATURAL UNITS: LENGTH IN FM)
# =============================================================================
F_PI = 93.0
M_PI = 138.0
HBAR_C = 197.327
MU_SQ = (M_PI / HBAR_C)**2
M_N_PHYS = 939.0
LAMBDA_NAT_SQ = 0.66778**2

# =============================================================================
# 2. МАТЕМАТИЧЕСКОЕ ЯДРО
# =============================================================================
def dsinc_da(a):
    out = np.empty_like(a)
    small = np.abs(a) < 1e-7
    out[small] = -a[small]/3.0 + (a[small]**3)/30.0
    aa = a[~small]
    out[~small] = (aa * np.cos(aa) - np.sin(aa)) / (aa**2)
    return out

def get_physics(r, f):
    a = np.pi - f
    s, c = np.sin(f), np.cos(f)
    g = np.sinc(a / np.pi)
    ratio = (a * g) / np.maximum(r, 1e-300)

    M = r**2 + LAMBDA_NAT_SQ * (ratio**2) * (s**2)
    U = s**2 + MU_SQ * (r**2) * (1 - c)

    dratio_dr = -ratio / np.maximum(r, 1e-300)
    gp = dsinc_da(a)
    dratio_df = -(g + a * gp) / np.maximum(r, 1e-300)

    M_r = 2*r + LAMBDA_NAT_SQ * (s**2) * 2 * ratio * dratio_dr
    M_f = LAMBDA_NAT_SQ * (2*s*c*(ratio**2) + (s**2) * 2 * ratio * dratio_df)
    U_f = np.sin(2*f) + MU_SQ * (r**2) * s

    return M, U, M_r, M_f, U_f, ratio

def ode_system(r, y):
    f, dfdr = y
    M, U, M_r, M_f, U_f, _ = get_physics(r, f)
    d2fdr2 = (U_f - M_r * dfdr - 0.5 * M_f * dfdr**2) / M
    return np.vstack((dfdr, d2fdr2))

def bc(ya, yb):
    return np.array([ya[0] - np.pi, yb[0] - 0.0])

# =============================================================================
# 3. РЕШЕНИЕ И АНАЛИЗ
# =============================================================================
r = np.geomspace(1e-4, 15.0, 3000)
y_init = np.vstack((np.pi * np.exp(-r/1.5), -(np.pi/1.5) * np.exp(-r/1.5)))

sol = solve_bvp(ode_system, bc, r, y_init, tol=1e-7, max_nodes=100000)
if not sol.success:
    raise RuntimeError("solve_bvp failed: " + sol.message)

r_s, f_s, df_s = sol.x, sol.y[0], sol.y[1]
M, U, _, _, _, ratio_s = get_physics(r_s, f_s)

# Масса и Радиус
prefactor_mass = 2.0 * np.pi * (F_PI**2) / HBAR_C
m_cl = prefactor_mass * simpson(0.5 * M * df_s**2 + U, x=r_s)
b_dens = -(1.0/(2*np.pi**2)) * (ratio_s**2) * df_s
norm_b = 4 * np.pi * simpson(r_s**2 * b_dens, x=r_s)
r_b = np.sqrt(4 * np.pi * simpson(r_s**4 * b_dens, x=r_s) / norm_b)

# Давление и D-терм
p_r = (F_PI**2 / (2.0 * HBAR_C * r_s**2)) * (0.5 * M * df_s**2 - U)
r2_pr = r_s**2 * p_r
dr2pr = np.zeros_like(r2_pr)
dr2pr[1:-1] = (r2_pr[2:] - r2_pr[:-2]) / (r_s[2:] - r_s[:-2])
dr2pr[0], dr2pr[-1] = (r2_pr[1]-r2_pr[0])/(r_s[1]-r_s[0]), (r2_pr[-1]-r2_pr[-2])/(r_s[-1]-r_s[-2])
p_t = np.empty_like(p_r); p_t[1:] = dr2pr[1:] / (2.0 * r_s[1:]); p_t[0] = p_r[0]
p_iso = (p_r + 2*p_t) / 3.0

D_val = -(4.0*np.pi/3.0) * (M_N_PHYS / HBAR_C) * simpson(r_s**4 * (p_iso / HBAR_C), x=r_s)
laue = 4 * np.pi * simpson(r_s**2 * (p_iso / HBAR_C), x=r_s)
boundary = (r_s[-1]**3 * (p_r[-1]/HBAR_C)) - (r_s[0]**3 * (p_r[0]/HBAR_C))

# =============================================================================
# 4. ВЫВОД (ТАБЛИЦА + ГРАФИКИ В ФАЙЛ)
# =============================================================================
print(f"\n{'Characteristic':<30} | {'Value':<15}")
print("-" * 50)
print(f"{'Baryon Number error':<30} | {abs(norm_b-1.0):<15.3e}")
print(f"{'Classical Mass (M_cl)':<30} | {m_cl:<15.2f} MeV")
print(f"{'Baryon Radius (R_B)':<30} | {r_b:<15.4f} fm")
print(f"{'D-term':<30} | {D_val:<15.5f}")
print(f"{'Laue Integral [fm^-1]':<30} | {laue:<15.3e}")
print(f"{'Boundary Check [fm^-1]':<30} | {boundary:<15.3e}")
print("-" * 50)

# Создание фигуры
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# График 1: Профиль
ax1.plot(r_s, f_s, color='blue', lw=2.5, label=r'$f(r)$')
ax1.set_xlabel('r [fm]', fontsize=12); ax1.set_ylabel('f [rad]', fontsize=12)
ax1.set_title('Chiral Profile Function', fontweight='bold'); ax1.grid(True, alpha=0.3)
ax1.legend()

# График 2: Давление
ax2.plot(r_s, p_iso, color='black', lw=2, label=r'$p_{iso}(r)$')
ax2.axhline(0, color='red', linestyle='--', alpha=0.6)
ax2.fill_between(r_s, p_iso, 0, where=(p_iso > 0), color='red', alpha=0.1, label='Repulsion')
ax2.fill_between(r_s, p_iso, 0, where=(p_iso < 0), color='blue', alpha=0.1, label='Attraction')
ax2.set_xlabel('r [fm]', fontsize=12); ax2.set_ylabel('Pressure [MeV/fm³]', fontsize=12)
ax2.set_title('Mechanical Pressure Distribution', fontweight='bold')
ax2.set_xlim(0, 3); ax2.grid(True, alpha=0.3); ax2.legend()

plt.tight_layout()

# СОХРАНЕНИЕ В ФАЙЛ (чтобы точно увидеть результат)
filename = "skyrme_report.png"
plt.savefig(filename, dpi=300)
print(f"\n[УСПЕХ] Графики сохранены в файл: {filename}")

# ПОПЫТКА ВЫВОДА НА ЭКРАН
plt.show()